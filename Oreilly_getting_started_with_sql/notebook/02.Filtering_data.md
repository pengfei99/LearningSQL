# 2 Filtering data

In chapter 1, we have seen how to retrive data with select. Now you may want to know how can we only retrive the data that instrest us, but not all the rows. We can use the **where** statement to filter data that satisfait certain conditions.

In this chapter, we will use another database **weather_stations**, this database only have one table called **station_data**

```sql
SELECT * from station_data;
```

## 2.1 Filtering digit columns

Below query should only get back records where the year field equals 2010

```sql
select * from station_data where year=2010
```

What if I want to get all records where year is not equals to 2010

```sql
-- two possible way to express inequality !=, or <>
select * from station_data where year!=2010

select * from station_data where year<>2010
```
These two syntaxes do the same thing. SQLite and most platforms now support both. However, **Microsoft Access and IBM DB2 only support <>**.

We can also qualify inclusive ranges using a BETWEEN statement, as shown here
(“inclusive” means that 2005 and 2010 are included in the range):
```sql
SELECT * FROM station_data
WHERE year BETWEEN 2005 and 2010

```

## 2.2 Combining multiple filtering condition

### 2.2.1 And operator

We can express the "between and" range with another expression. For instance the year must be greater than or equal to 2005 and less than or equal to 2010. We need to comparation and combine the result of the two comparation with an **and**.

```sql
select * from station_data
where year >= 2005 and year<= 2010;
```

Note the "between and" express an inclusive range, for not inclusive range, we can not use it. 

```sql
select * from station_data
where year > 2005 and year< 2010;
```

### 2.2.2 Or operator

The OR operator will return the record if at least one of the criteria is true for the record. For instance, if we wanted only records with months 3, 6, 9, or 12, we can use below query:

```sql
select * from station_data
where month=3 
or month=6
or month=9
or month=12;
```

### 2.2.3 In operator

In the above example, we tested column month with a list of possible value. In this kind of situation, we can use the **In** operator.

```sql
select * from station_data
where month in (3,6,9,12);

```

We can also express the negation of the in operator by adding not infront of **in** operator.

```sql
select * from station_data
where month not in (3,6,9,12);
```

### 2.2.4 Arithmetic operators

We can notice 3,6,9,12 can all be divided by 3. So we can also use another way to get the same records as above examples.

```sql
select * from station_data
where month%3=0;
```

**Note Oracle does not support the modulus operator. It instead uses the MOD() function.**

## 2.3 Filtering text columns

The rules for qualifying text fields follow the same structure, although there are subtle(small) differences. You can **use =, AND, OR, and IN statements with text**. However, when using text, you must wrap literals (or text values you specify) **in single quotes**.

```sql
-- correct query
SELECT * FROM station_data
WHERE report_code = '513A63';

SELECT * FROM station_data
WHERE report_code = "513A63";

-- bad query
SELECT * FROM station_data
WHERE report_code = 513A63;
```

If we do not add " or ' on 513A63, the SQL software will get confused and think 513A63 is a column rather than a text value. This single-quote rule applies to all text operations, including this IN operation

```sql
SELECT * FROM station_data
WHERE report_code IN ('513A63','1F8A7B','EF616A');
```

### 2.3.1 Other useful functions

#### filter by using length

**length** operator can get the length of a text field. For instance, all report_code contains six characters or digit. Below query returns all rows that has incorrect report_code. 

```sql
SELECT * FROM station_data
WHERE length(report_code) != 6
```

#### Wild card text filtering with like operator

Another common operation is to use wildcards with LIKE followed by a regular expression, in the regular expression:
- % : means any number of characters an
- _ : means any single character. 
- Any other character is interpreted literally. 

So, if you wanted to find all report codes that start with the letter “A,” you would run this statement to find “A” followed by any characters

```sql
select * from station_data
where report_code like 'A%';
```

If you wanted all report codes that have a “B” as the first character and a “C” as the third character, 

```sql
select * from station_data
where report_code like 'B_C%';
```

## 2.4 Filtering boolean column

Booleans are true/false values. In the database world, typically **false is expressed as 0 and true is expressed as 1**. Some database platforms **(like MySQL) allow you to implicitly use the words true and false**

**SQLite, however, does not support this. It expects you to explicitly use 1 for true and 0 for false**. For instance, below query gets all records where there was tornado and hail:

```sql
select * from station_data
where tornado=1 AND hail=1;
```

If you are looking for just true values, you do not even have to use the = 1 expression. Because the fields are already Boolean (behind the scenes, **every WHERE condition boils down to a Boolean expression**), they inherently qualify by themselves. Hence, you can achieve the same results by running the following query:

```sql 
select * from station_data
where tornado AND hail;
```

However, qualifying for false conditions needs to be explicit. To get all records with no tornado but with hail, run this query:
```sql
SELECT * FROM station_data
WHERE tornado = 0 AND hail = 1;

-- You can also use the NOT keyword to qualify tornado as false:
SELECT * FROM station_data
WHERE NOT tornado AND hail; 
```

## 2.5 Handling null

You may have noticed that some columns, such as station_pressure and snow_depth , have null values. **A null is a value that has no value. It is the complete absence of any content. It is a vacuous state**.

In sql, **Null values cannot be determined with an = . You need to use the IS NULL or IS NOT NULL statements to identify null values**

Below query returns all rows that snow_depth is null

```sql
select * from station_data 
where snow_depth is null;
```

### 2.5.1 Why we even have null values in the database? Can we replace null by 0 for snow_depth?

The null values is useful for some use case. For example, for column such as snow_depth or precipitation, it does make sense. Not because it was a sunny day (in this case, it is better to record the values as 0), but rather because some stations might not have the necessary instruments to take those measurements. It might be misleading to set those values to 0 (which implies data was recorded), so those measurements should be left null.

In some columns, we can not have null values. For example, the **station_number** column should be designed that it never allows nulls. Because if it's null, all the rest columns of this row become orphan data that belongs to no station. 

We can see that nulls values are ambiguous and it can be difficult to determine their business meaning. It is important that nullable columns (columns that are allowed to have null values) **have documented what a null value means from a business perspective**. **Otherwise, nulls should be banned from those table columns**.

Do not confuse nulls with empty text(i.e., '' ). This also applies to whitespace text (i.e., ' ') . These will be treated as values and never will be considered null. A null is definitely not the same as 0 either, because 0 is a value, whereas null is an absence of a value.

### 2.5.2 Problems caused by null values

We know that precipitation column has null values, try to run the following query. You can notice that the returned rows do not contain any null values. Because null is not 0 or any number, it will not qualify to any condition. So the **precipitation <= 0.5** filtered all
rows that contains null value. 

```sql
SELECT station_number, precipitation FROM station_data
WHERE precipitation <= 0.5
```

But having a null value does not mean the precipitation > 0.5, so we may want to keep those rows that have null values. We can have them by using the following query

```sql
SELECT station_number, precipitation FROM station_data
WHERE precipitation is null 
OR precipitation <= 0.5
```
The above query works, but we have a more elegant way of handling null values. We can use the **coalesce() function** 
- coalesce(col_name,replacement_value): It takes a column name that may have null value, if the row vaule is null, then replace it with the given replacement_value. 

Below query use coalesce to replace all null value of column precipitation by 0 than compare them with <=0.5. This will not modify the origin table.

```sql
SELECT * FROM station_data
WHERE coalesce(precipitation, 0) <= 0.5;
```

If we want the other user can use the replaced value, we can create a new column by using below query
```sql
SELECT report_code, coalesce(precipitation, 0) as rainfall
FROM station_data;
```

## 2.6 Grouping Conditions

When you start chaining AND and OR together, you need to make sure that you organize each set of conditions between each OR in a way that groups related conditions.

For example, we need to find all rows that snow or sleet(rain with snow). For sleet to happen, there must be rain and a temperature less than or equal to 32 degrees. We could write below query.

```sql
SELECT * FROM station_data
WHERE rain = 1 AND temperature <= 32
OR snow_depth > 0;
```

We are lucky this works, because AND, OR have the same priority, sql resolve from left to right. So **rain = 1 AND temperature <= 32** resolved to a value, then this value get resolved with **OR snow_depth > 0**. But for a begginer, this can be confusing, he will wonder if AND condition get resolved first or the OR condition get resolved first.

To avoid this, we can explicitly group conditions in parentheses. This makes not only makes the semantics clearer, but also the execution safer.

```sql
SELECT * FROM station_data
WHERE (rain = 1 AND temperature <= 32)
OR snow_depth > 0
```
